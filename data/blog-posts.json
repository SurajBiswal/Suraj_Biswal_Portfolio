[
  {
    "id": 1,
    "title": "Binary Tree Problems Solved: Brute, Better, Optimal",
    "slug": "binary-tree-problems-solved-brute-better-optimal",
    "category": "dsa",
    "excerpt": "A comprehensive guide covering 20 binary tree questions with detailed explanations of brute-force, better, and optimal approaches for each problem.",
    "content": "Coming soon...",
    "author": "Suraj Biswal",
    "publishedDate": "2025-06-21",
    "readTime": "15 min read",
    "tags": [
      "binary-trees",
      "algorithms",
      "data-structures",
      "interview-prep",
      "time-complexity"
    ],
    "featured": true
  },
  {
    "id": 2,
    "title": "Graph Problems Solved: DFS, BFS, Cycle Detection, and More",
    "slug": "graph-problems-solved-dfs-bfs-cycle-detection-and-more",
    "category": "dsa",
    "excerpt": "Explore graph algorithms including depth-first search, breadth-first search, cycle detection, and shortest path algorithms with practical implementations.",
    "content": "Coming soon...",
    "author": "Suraj Biswal",
    "publishedDate": "2025-06-21",
    "readTime": "13 min read",
    "tags": [
      "graphs",
      "dfs",
      "bfs",
      "algorithms",
      "cycle-detection",
      "shortest-path"
    ],
    "featured": false
  },
  {
    "id": 3,
    "title": "Top Array Interview Problems: Sliding Window to Two Pointers",
    "slug": "top-array-interview-problems-sliding-window-to-two-pointers",
    "category": "dsa",
    "excerpt": "Master array manipulation techniques from sliding window to two pointers, with optimized solutions for the most common interview problems.",
    "content": "Coming soon...",
    "author": "Suraj Biswal",
    "publishedDate": "2025-06-21",
    "readTime": "8 min read",
    "tags": [
      "arrays",
      "sliding-window",
      "two-pointers",
      "algorithms",
      "interview-prep"
    ],
    "featured": true
  },
  {
    "id": 4,
    "title": "Mastering Recursion and Backtracking",
    "slug": "mastering-recursion-and-backtracking",
    "category": "dsa",
    "excerpt": "Deep dive into recursion and backtracking techniques with solutions to classic problems like N-Queens, Sudoku Solver, and generating subsets and permutations.",
    "content": "Coming soon...",
    "author": "Suraj Biswal",
    "publishedDate": "2025-06-21",
    "readTime": "12 min read",
    "tags": [
      "recursion",
      "backtracking",
      "algorithms",
      "n-queens",
      "sudoku",
      "permutations"
    ],
    "featured": false
  },
  {
    "id": 5,
    "title": "Low-Level Design: Real-World Object-Oriented Scenarios",
    "slug": "low-level-design-real-world-object-oriented-scenarios",
    "category": "system-design",
    "excerpt": "Learn object-oriented design principles through real-world system implementations including Parking Lot, BookMyShow, Cache, Splitwise, and URL Shortener.",
    "content": "Coming soon...",
    "author": "Suraj Biswal",
    "publishedDate": "2025-06-21",
    "readTime": "13 min read",
    "tags": [
      "low-level-design",
      "object-oriented",
      "design-patterns",
      "SOLID",
      "parking-lot",
      "url-shortener"
    ],
    "featured": true
  },
  {
    "id": 6,
    "title": "High-Level Design: Architecting Instagram, WhatsApp, YouTube",
    "slug": "high-level-design-architecting-instagram-whatsapp-youtube",
    "category": "system-design",
    "excerpt": "Explore high-level architecture design for popular platforms like Instagram, WhatsApp, and YouTube, covering scalable services, load balancing, and data sharding.",
    "content": "Coming soon...",
    "author": "Suraj Biswal",
    "publishedDate": "2025-06-21",
    "readTime": "11 min read",
    "tags": [
      "high-level-design",
      "system-architecture",
      "scalability",
      "load-balancing",
      "sharding",
      "microservices"
    ],
    "featured": false
  },
  {
    "id": 7,
    "title": "System Design Interview Questions: Practice with Real Scenarios",
    "slug": "system-design-interview-questions-practice-with-real-scenarios",
    "category": "system-design",
    "excerpt": "Prepare for system design interviews with a structured approach to both low-level and high-level design questions, complete with example solutions.",
    "content": "Coming soon...",
    "author": "Suraj Biswal",
    "publishedDate": "2025-06-21",
    "readTime": "7 min read",
    "tags": [
      "system-design",
      "interviews",
      "scalability",
      "architecture",
      "design-patterns",
      "case-studies"
    ],
    "featured": true
  },
  {
    "id": 8,
    "title": "OS Concepts for Interviews: Threads, Scheduling, and Deadlocks",
    "slug": "os-concepts-for-interviews-threads-scheduling-and-deadlocks",
    "category": "cs-fundamentals",
    "excerpt": "A comprehensive guide to operating system concepts essential for technical interviews, including process management, thread synchronization, and deadlock prevention.",
    "content": "Coming soon...",
    "author": "Suraj Biswal",
    "publishedDate": "2025-06-21",
    "readTime": "7 min read",
    "tags": [
      "operating-systems",
      "threads",
      "process-scheduling",
      "deadlocks",
      "concurrency",
      "memory-management"
    ],
    "featured": false
  },
  {
    "id": 9,
    "title": "DBMS Simplified: Transactions, Isolation Levels, and Indexing",
    "slug": "dbms-simplified-transactions-isolation-levels-and-indexing",
    "category": "cs-fundamentals",
    "excerpt": "Demystifying database management systems with a focus on transaction processing, isolation levels, concurrency control, and indexing strategies.",
    "content": "Coming soon...",
    "author": "Suraj Biswal",
    "publishedDate": "2025-06-21",
    "readTime": "10 min read",
    "tags": [
      "dbms",
      "transactions",
      "acid",
      "isolation-levels",
      "indexing",
      "normalization"
    ],
    "featured": true
  },
  {
    "id": 10,
    "title": "Computer Networks for Developers: HTTP, DNS, Load Balancing",
    "slug": "computer-networks-for-developers-http-dns-load-balancing",
    "category": "cs-fundamentals",
    "excerpt": "An application-focused approach to computer networking, covering protocols, DNS resolution, load balancing, and content delivery networks relevant to developers.",
    "content": "Coming soon...",
    "author": "Suraj Biswal",
    "publishedDate": "2025-06-21",
    "readTime": "12 min read",
    "tags": ["networking", "http", "dns", "tcp-ip", "load-balancing", "cdn"],
    "featured": false
  },
  {
    "id": 11,
    "title": "React Patterns for Scalable Frontend Development",
    "slug": "react-patterns-for-scalable-frontend-development",
    "category": "web-development",
    "excerpt": "Explore advanced React patterns and architectures that enable building maintainable, scalable frontend applications for enterprise environments.",
    "content": "Coming soon...",
    "author": "Suraj Biswal",
    "publishedDate": "2025-06-21",
    "readTime": "7 min read",
    "tags": [
      "react",
      "frontend",
      "design-patterns",
      "component-architecture",
      "state-management",
      "hooks"
    ],
    "featured": true
  },
  {
    "id": 12,
    "title": "Mastering JavaScript: Closures, Event Loop, and Async Patterns",
    "slug": "mastering-javascript-closures-event-loop-and-async-patterns",
    "category": "web-development",
    "excerpt": "Deep dive into JavaScript's core concepts including closures, execution context, the event loop, and asynchronous programming patterns.",
    "content": "Coming soon...",
    "author": "Suraj Biswal",
    "publishedDate": "2025-06-21",
    "readTime": "6 min read",
    "tags": [
      "javascript",
      "closures",
      "event-loop",
      "async-await",
      "promises",
      "functional-programming"
    ],
    "featured": false
  },
  {
    "id": 13,
    "title": "Web Performance Optimization: Lazy Loading, Debouncing, and More",
    "slug": "web-performance-optimization-lazy-loading-debouncing-and-more",
    "category": "web-development",
    "excerpt": "Practical techniques to optimize web application performance, from code splitting and lazy loading to debouncing user interactions and resource prioritization.",
    "content": "Coming soon...",
    "author": "Suraj Biswal",
    "publishedDate": "2025-06-21",
    "readTime": "14 min read",
    "tags": [
      "performance",
      "lazy-loading",
      "debouncing",
      "code-splitting",
      "web-vitals",
      "optimization"
    ],
    "featured": true
  },
  {
    "id": 14,
    "title": "Strategy Design Pattern: Flexible Behavior at Runtime",
    "slug": "strategy-design-pattern-low-level",
    "category": "system-design",
    "excerpt": "Understand the Strategy Design Pattern through a real-world Duck Simulation example. Learn how to encapsulate behaviors, follow the Open/Closed Principle, and allow runtime flexibility.",
    "content": "## Strategy Design Pattern Explanation\n\nThe Strategy Pattern is a behavioral design pattern that allows selecting an algorithm (or behavior) at runtime. Instead of defining multiple behaviors in a single class, we encapsulate them in separate classes and make them interchangeable.\n\nIt follows the **Open/Closed Principle**, meaning new behaviors can be added without modifying existing code.\n\n---\n\n### 🦆 Real-World Example: Duck Simulation\nImagine a Duck Simulation game where different ducks have different flying and quacking behaviors:\n- Some ducks fly with wings\n- Some can't fly (rubber ducks)\n- Some quack loudly\n- Some stay silent (wooden ducks)\n\n---\n\n### 🛠 Step 1: Create Behavior Interfaces\n```java\n// Fly behavior\ninterface FlyBehavior {\n    void fly();\n}\n\nclass FlyWithWings implements FlyBehavior {\n    public void fly() {\n        System.out.println(\"I'm flying with wings!\");\n    }\n}\n\nclass NoFly implements FlyBehavior {\n    public void fly() {\n        System.out.println(\"I can't fly.\");\n    }\n}\n\n// Quack behavior\ninterface QuackBehavior {\n    void quack();\n}\n\nclass QuackLoud implements QuackBehavior {\n    public void quack() {\n        System.out.println(\"Quack! Quack!\");\n    }\n}\n\nclass SilentQuack implements QuackBehavior {\n    public void quack() {\n        System.out.println(\"...\");\n    }\n}\n```\n\n---\n\n### 🦢 Step 2: Define the Duck Base Class\n```java\nabstract class Duck {\n    FlyBehavior flyBehavior;\n    QuackBehavior quackBehavior;\n\n    public void performFly() {\n        flyBehavior.fly();\n    }\n\n    public void performQuack() {\n        quackBehavior.quack();\n    }\n\n    public void setFlyBehavior(FlyBehavior fb) {\n        this.flyBehavior = fb;\n    }\n\n    public void setQuackBehavior(QuackBehavior qb) {\n        this.quackBehavior = qb;\n    }\n\n    abstract void display();\n}\n```\n\n---\n\n### 🧩 Step 3: Implement Specific Ducks\n```java\nclass MallardDuck extends Duck {\n    public MallardDuck() {\n        flyBehavior = new FlyWithWings();\n        quackBehavior = new QuackLoud();\n    }\n\n    public void display() {\n        System.out.println(\"I'm a Mallard Duck.\");\n    }\n}\n\nclass RubberDuck extends Duck {\n    public RubberDuck() {\n        flyBehavior = new NoFly();\n        quackBehavior = new SilentQuack();\n    }\n\n    public void display() {\n        System.out.println(\"I'm a Rubber Duck.\");\n    }\n}\n```\n\n---\n\n### 🧪 Step 4: Test the Pattern\n```java\npublic class DuckSimulator {\n    public static void main(String[] args) {\n        Duck mallard = new MallardDuck();\n        mallard.display();\n        mallard.performFly();\n        mallard.performQuack();\n\n        Duck rubberDuck = new RubberDuck();\n        rubberDuck.display();\n        rubberDuck.performFly();\n        rubberDuck.performQuack();\n\n        // Change behavior at runtime\n        rubberDuck.setFlyBehavior(new FlyWithWings());\n        System.out.println(\"Now the rubber duck learns to fly!\");\n        rubberDuck.performFly();\n    }\n}\n```\n\n---\n\n### ✅ Key Benefits\n- **Encapsulation of behaviors** → Separate reusable strategies\n- **Open/Closed Principle** → Add behaviors without changing existing code\n- **Flexibility** → Swap behaviors at runtime\n\n---\n\n### 🔍 Interview-Ready Summary\n> \"The Strategy Pattern allows dynamic behavior selection at runtime. It encapsulates interchangeable algorithms (strategies), enabling flexibility and adhering to the Open/Closed Principle. For example, different duck types can fly or quack differently using strategy classes.\"\n\n---\n\n### ▶️ Execution Flow Explained\n| Step | Method Call | Behavior |\n|------|-------------|----------|\n| 1 | `Duck mallard = new MallardDuck();` | Sets fly & quack behavior |\n| 2 | `mallard.display();` | Prints `I'm a Mallard Duck.` |\n| 3 | `mallard.performFly();` | Prints `I'm flying with wings!` |\n| 4 | `mallard.performQuack();` | Prints `Quack! Quack!` |\n\n---\n\n### 🧠 Why Not Just Use Abstract Methods?\nUsing abstract `fly()` and `quack()` in each duck class:\n- ❌ Duplicates code\n- ❌ Cannot change behavior at runtime\n- ❌ Violates Open/Closed Principle\n\n---\n\n### ✅ Why Strategy Pattern Wins\n- ✔️ Reusable behavior classes\n- ✔️ Behavior can change at runtime (`setFlyBehavior()`)\n- ✔️ Follows SOLID principles (especially OCP)\n\n---\n\n### 🧨 Need to Add Rocket Duck?\nJust create:\n```java\nclass FlyWithRocket implements FlyBehavior {\n    public void fly() {\n        System.out.println(\"I'm flying with a rocket!\");\n    }\n}\n```\nAnd assign:\n```java\nmallard.setFlyBehavior(new FlyWithRocket());\nmallard.performFly();\n```\n\n✔️ No need to touch `Duck` or `MallardDuck` classes!\n\n---\n\n### ✅ Conclusion\nThe Strategy Pattern is essential for clean, extensible, and flexible design. It minimizes duplication, supports runtime flexibility, and aligns perfectly with the Open/Closed Principle — making it a go-to choice for dynamic behavior management.",
    "author": "Suraj Biswal",
    "publishedDate": "2025-06-22",
    "readTime": "12 min read",
    "tags": [
      "strategy-pattern",
      "design-patterns",
      "low-level-design",
      "duck-simulation",
      "oop",
      "java"
    ],
    "featured": true
  }
]
